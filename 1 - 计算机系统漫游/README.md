# 第1章 计算机系统漫游

计算机系统是由`硬件`和`系统软件`组成。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。

## 1.1 信息就是位+上下文

以下将从`hello.c`示例程序来介绍`C`。帮助了解系统上执行`hello`程序时，系统发生了什么以及为什么会这样。

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

`hello.c`程序的生命周期是从一个*源程序*开始的，即程序员通过编辑器创建并保存文本文件，文件名为`hello.c`。源程序实际上就是一些`01`需序列，$8$个位组织为成一组，成为一个字节。每个字节表示程序中的某些文本字符

`hello.c`的表示方法说明：系统中的所有的信息，都是由一串比特表示的，唯一能区分不同的数据对象的方法就是读这些数据对象的上下文。

## 1.2 程序被其他程序翻译成不同的格式

`hello.c`程序的生命周期是从一个高级`C`语言程序开始的。为了运行这个程序，每条语句都必须被其他程序转化为一系列的低级`机器语言`指令。然后这些指令按照一种成为可执行目标程序的格式打包好，并以二进制磁盘文件的形式保存。

在`Unix`系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```shell
linux> gcc -o hello hello.c
```

以上命令`GCC`编译器驱动程序读取源程序`hello.c`，并把它翻译成一个可执行目标文件`hello`。这个翻译如下图所示。执行四个步骤（预处理器、编译器、汇编器和链接器）一起构成编译系统。

<div align=center>
<img src="assets/image-20230703234646274.png" alt="image-20230703234646274" style="zoom:67%;" />
</div>

* **预处理阶段**。预处理（cpp）根据以字符`#`开头的命令，修改原始的`C`程序。`hello.c`在程序开头读取系统头文件`stdio.h`的内容，并把它直接插入程序文本中。结果得到另一个`C`程序，通常后缀为`.i`。
  
* **编译阶段**。编译器（ccl）将文本文件翻译成文本文件`hello.s`，它包含一个汇编语言程序。如下所示：

```assembly
main: 
    subq $8, %rsp
    movl $.LCO, %edi
    call puts
    movl $0, %eax
    addq $8, %rsp
    ret
```

以上代码描述了以一种文本格式描述了低级机器语言指令，汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。

* **汇编阶段**。汇编器（as）将`hello.s`翻译成机器语言指令，把这些指令打包成一种可重定向定位目标程序的格式，并将结果保存在目标文件`hello.o`中。它包含的$17$个字节是函数`main`的指令编码。

* **链接阶段**。`hello`程序调用了`printf`函数，它是每个`C`编译器都提供的标准`C`库中的一个函数。`printf`函数存在于一个名为`printf.o`的单独的预编译好了的目标文件中。链接器（ld）就负责处理这种合并。结果得到`hello`文件，它是一个可执行目标文件可以被加载到内存中，由系统执行。

## 1.3 了解编译系统如何工作是大有益处的

一些重要的原因促使程序员必须知道编译系统是如何工作的。

* **优化程序性能**。为了在`C`程序总做出好的编码选择，确实需要了解一些机器代码以及编译器将不同的`C`语言转化为机器代码的方式。

* **理解链接时出现的错误**。一些最令人困扰的程序错误往往都与连接器操作有关。

* **避免安全漏洞**。缓冲区溢出错误是造成安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。

## 1.4 处理器读并解释储存在内存中的指令

源程序已经被翻译成了可执行目标文件`hello`，并被存在磁盘上。要想在`Unix`系统上运行该可执行文件，我们将它的文件名输入到称为`shell`的应用程序中：

```assembly
linux> ./hello
hello, world
```

`shell`是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果首个单词不是内置`shell`命令，那么`shell`就会假设这是一个可执行文件的名字，它将加载并运行这个文件。

### 1.4.1 系统的硬件组成

为了理解运行`hello`程序时发生了什么，我们需要了解一个典型系统的硬件组织，下图时近期`Intel`系统产品族的模型。以下分阶段对其进行详尽介绍。

<div align=center>
<img src="assets/image-20230704004004684.png" alt="image-20230704004004684" style="zoom: 80%;" />
</div>

1. **总线**

一组电子管道，称作总线，它携带信息字节并负责在各部件间传递。通常总线被设计成传送定长的字节块，即*字（word）*。字中的字节数时一个基本的系统参数，各个系统中都不尽相同。大多机器字长要么是$4$个字节（$32$位），要么是$8$个字节（64位）。

2. **I/O设备**

`I/O`设备是系统与外部世界的联系通道。示例系统包括四个`I/O`设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。

每个`I/O`设备都通过一个控制器或适配器与`I/O`总线相连。控制器是`I/O`设备本身或者系统的主印制电路板上的芯片组。而适配器则是一块插在主板插槽上的卡。

3. **主存**

主存是一个临时存储设备，在处理执行程序时，用来存放程序和程序处理的数据。主存是由一组动态随机存取器芯片组成的。存储器是一个线性的字节数组，每个字节都有其唯一的地址。一般来说，组成程序的每条机器指令都由不同数量的字节构成。

4. **处理器**

中央处理单元（CPU），是解释或执行存储在主存中指令的引擎。处理器的核心是一个大小位一个字的存储设备或寄存器，称为程序计算器（PC）。在任何时刻，PC都指向主存中某条机器语言指令（指令所在的地址）。

从系统通电开始，直到系统断电，处理器一直不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。处理器从PC指向的内存中读取指令，解释指令中的位，执行该指令之时的简单操作，然后更新PC，使其指向下一条指令。

寄存器文件时一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都由唯一的名字。ALU计算新的数据和地址。

处理器看上去是它的指令集架构的简单是实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，处理器的指令集架构和处理器的微体系结构需要区分开来，前者描述的是每条机器代码指令的效果，后者描述的是处理器实际上是如何实现的。

### 1.4.2 运行hello程序

